
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Sun Mar 19 23:28:29 CST 2023
//----------------------------------------------------

package analizadores;

import java_cup.runtime.*;
import java.io.FileWriter;
import java.io.IOException;
import main.metodoarbol.Nodo;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Sun Mar 19 23:28:29 CST 2023
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\032\000\002\002\004\000\002\002\003\000\002\013" +
    "\002\000\002\014\002\000\002\015\002\000\002\003\014" +
    "\000\002\005\004\000\002\005\003\000\002\007\004\000" +
    "\002\007\003\000\002\016\002\000\002\010\007\000\002" +
    "\017\002\000\002\006\012\000\002\004\004\000\002\004" +
    "\003\000\002\020\002\000\002\012\010\000\002\011\005" +
    "\000\002\011\005\000\002\011\004\000\002\011\004\000" +
    "\002\011\004\000\002\011\003\000\002\011\003\000\002" +
    "\011\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\066\000\004\015\006\001\002\000\004\002\000\001" +
    "\002\000\004\002\070\001\002\000\004\024\uffff\001\002" +
    "\000\004\024\012\001\002\000\006\020\023\024\012\001" +
    "\002\000\006\020\ufffa\024\ufffa\001\002\000\004\010\013" +
    "\001\002\000\004\020\014\001\002\000\004\011\015\001" +
    "\002\000\004\012\016\001\002\000\004\025\017\001\002" +
    "\000\004\007\ufff5\001\002\000\004\007\021\001\002\000" +
    "\006\020\ufff4\024\ufff4\001\002\000\006\017\ufff2\020\ufff2" +
    "\001\002\000\004\011\044\001\002\000\006\020\ufffb\024" +
    "\ufffb\001\002\000\006\017\027\020\023\001\002\000\006" +
    "\017\ufff3\020\ufff3\001\002\000\004\017\030\001\002\000" +
    "\004\020\ufffe\001\002\000\004\020\032\001\002\000\004" +
    "\010\040\001\002\000\006\016\ufff8\020\ufff8\001\002\000" +
    "\006\016\ufffd\020\032\001\002\000\004\016\037\001\002" +
    "\000\006\016\ufff9\020\ufff9\001\002\000\004\002\ufffc\001" +
    "\002\000\004\026\041\001\002\000\004\007\ufff7\001\002" +
    "\000\004\007\043\001\002\000\006\016\ufff6\020\ufff6\001" +
    "\002\000\004\012\045\001\002\000\022\004\055\005\053" +
    "\006\050\013\046\014\056\021\054\022\052\023\047\001" +
    "\002\000\022\004\055\005\053\006\050\013\046\014\056" +
    "\021\054\022\052\023\047\001\002\000\024\004\uffe9\005" +
    "\uffe9\006\uffe9\007\uffe9\013\uffe9\014\uffe9\021\uffe9\022\uffe9" +
    "\023\uffe9\001\002\000\022\004\055\005\053\006\050\013" +
    "\046\014\056\021\054\022\052\023\047\001\002\000\004" +
    "\007\ufff1\001\002\000\024\004\uffe8\005\uffe8\006\uffe8\007" +
    "\uffe8\013\uffe8\014\uffe8\021\uffe8\022\uffe8\023\uffe8\001\002" +
    "\000\022\004\055\005\053\006\050\013\046\014\056\021" +
    "\054\022\052\023\047\001\002\000\024\004\uffea\005\uffea" +
    "\006\uffea\007\uffea\013\uffea\014\uffea\021\uffea\022\uffea\023" +
    "\uffea\001\002\000\022\004\055\005\053\006\050\013\046" +
    "\014\056\021\054\022\052\023\047\001\002\000\022\004" +
    "\055\005\053\006\050\013\046\014\056\021\054\022\052" +
    "\023\047\001\002\000\024\004\uffeb\005\uffeb\006\uffeb\007" +
    "\uffeb\013\uffeb\014\uffeb\021\uffeb\022\uffeb\023\uffeb\001\002" +
    "\000\022\004\055\005\053\006\050\013\046\014\056\021" +
    "\054\022\052\023\047\001\002\000\024\004\uffef\005\uffef" +
    "\006\uffef\007\uffef\013\uffef\014\uffef\021\uffef\022\uffef\023" +
    "\uffef\001\002\000\024\004\uffed\005\uffed\006\uffed\007\uffed" +
    "\013\uffed\014\uffed\021\uffed\022\uffed\023\uffed\001\002\000" +
    "\004\007\064\001\002\000\006\017\ufff0\020\ufff0\001\002" +
    "\000\022\004\055\005\053\006\050\013\046\014\056\021" +
    "\054\022\052\023\047\001\002\000\024\004\uffee\005\uffee" +
    "\006\uffee\007\uffee\013\uffee\014\uffee\021\uffee\022\uffee\023" +
    "\uffee\001\002\000\024\004\uffec\005\uffec\006\uffec\007\uffec" +
    "\013\uffec\014\uffec\021\uffec\022\uffec\023\uffec\001\002\000" +
    "\004\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\066\000\006\002\004\003\003\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\013\006\001\001\000\006" +
    "\005\007\006\010\001\001\000\010\004\024\006\023\012" +
    "\021\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\017\017\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\012\025\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\014\030\001\001\000\006\007\033\010" +
    "\032\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\010\035\015\034\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\016\041" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\011\050\001\001\000\004\011\066\001\001" +
    "\000\002\001\001\000\004\011\064\001\001\000\004\020" +
    "\062\001\001\000\002\001\001\000\004\011\061\001\001" +
    "\000\002\001\001\000\004\011\057\001\001\000\004\011" +
    "\056\001\001\000\002\001\001\000\004\011\060\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\011\065\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



public static int contid=1;
	public static int IDS=1;
	public static Nodo Raiz;
	public static String nm;
	
	public static HashMap lexemas=new HashMap();
	public static HashMap siguientes=new HashMap();
	public static HashMap hojas=new HashMap();
	public static HashMap sigs=new HashMap();
	
	public static HashMap estados=new HashMap();
	public static ArrayList aceptacion=new ArrayList();
	public static int contadorEstados=0;
	public static int verificar=0;
	
	public static HashMap conjuntos=new HashMap();
	public static HashMap exps=new HashMap();
	public static String expReg="";
	public static HashMap estadosAlrv=new HashMap();
	
	public static String codigoAFD="";//enlace de nodos
	public static String codigoNodos="";//creacion de nodos
	
	public static boolean p_a=false;//para or
	public static String cerrar="";
	
	public static String json="";

	
	public static boolean p_aC=false;//para conca
	
	public static HashMap expRegVerificada=new HashMap();
	
	public static void graficarArbol(Nodo act, String nombre){
        FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("src/Graficos/Grafico arboles/" + nombre + ".dot");
            pw = new PrintWriter(fichero);
            pw.println("digraph G{");
            pw.println("rankdir=UD");
            pw.println("node[shape=box]");
            pw.println("concentrate=true");
            pw.println(act.getCodigoInterno());
            pw.println("}");
        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo"+e);
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
        //para compilar el archivo dot y obtener la imagen
        try {
            //direcciï¿½n doonde se ecnuentra el compilador de graphviz
            String dotPath = "C:/Program Files/Graphviz/bin/dot.exe";
            //direcciï¿½n del archivo dot
            String fileInputPath = "src/Graficos/Grafico arboles/" + nombre + ".dot";
            //direcciï¿½n donde se creara la magen
            String fileOutputPath = "src/Graficos/Grafico arboles/" + nombre + ".jpg";
            //tipo de conversï¿½n
            String tParam = "-Tjpg";
            String tOParam = "-o";

            String[] cmd = new String[5];
            cmd[0] = dotPath;
            cmd[1] = tParam;
            cmd[2] = fileInputPath;
            cmd[3] = tOParam;
            cmd[4] = fileOutputPath;

            Runtime rt = Runtime.getRuntime();

            rt.exec(cmd);

        } catch (Exception ex) {
            ex.printStackTrace();
        } finally {
        }
    }
    
	
	public static String pop(String str) {
		if (str == null) {
			return null;
		}
		return str.replaceFirst(",$", "");
	}

	
	
	public static void recorrido(Nodo raiz) {
		
		if(raiz!=null){
    		//System.out.println(raiz.getValor());
    		recorrido(raiz.hizq);
    		
    		if(raiz.getIdentificador()!=0) {
    			hojas.put(String.valueOf(raiz.getIdentificador()), raiz.getValor());
    		}
    		
    		if(raiz.getValor()==".") {
    			if(siguientes.containsKey(pop(raiz.hizq.getUltimo()))) {
    				siguientes.replace(pop(raiz.hizq.getUltimo()), siguientes.get(pop(raiz.hizq.getUltimo()))+","+pop(raiz.hder.getprimero()));
    			}else {
    				siguientes.put(pop(raiz.hizq.getUltimo()), pop(raiz.hder.getprimero()));
    			}
    			
    		}
    		
    		if(raiz.getValor()=="*" || raiz.getValor()=="+") { // || raiz.getValor()=="?"
    			if(siguientes.containsKey(pop(raiz.getUltimo()))) {
    				siguientes.replace(pop(raiz.getUltimo()), siguientes.get(pop(raiz.getprimero()))+","+pop(raiz.getprimero()));
    			}
    			else {
    				siguientes.put(pop(raiz.getUltimo()), pop(raiz.getprimero()));
    			}
    			
    		}
    		
    		recorrido(raiz.hder);
		}
	}
	
	
	
	public static void inOrden() {
		siguientes.clear();
		sigs.clear();
		hojas.clear();
		
		estados.clear();
		aceptacion.clear();
		verificar=0;
    	contadorEstados=0;
    	contid=1;
    	IDS=1;
    	
    	
    	expReg="";
    	
    	estadosAlrv.clear();
    	codigoAFD="";
    	codigoNodos="";
    	
    	
		recorrido(Raiz);
		//System.out.println(siguientes);
		//System.out.println(hojas);
		generarSiguientes();
		
	}
	
	public static void generarSiguientes() {
		String llavess=siguientes.keySet().toString();
		String valss=siguientes.values().toString().replace("[", "").replace("]", "").replace(" ", "");
		
		String llaves[]=siguientes.keySet().toString().replace("[", "").replace("]", "").replace(" ", "").split(",");
		String vals[]=siguientes.values().toString().replace("[", "").replace("]", "").replace(" ", "").split(",");
		
		//recorriendo llaves 
		for(int i=0;i<llaves.length;i++) {
				//System.out.println(llaves.charAt(i));
				if(!sigs.containsKey(llaves[i])) {
					sigs.put(llaves[i],"");
				}
			
		}
		
		//recorriendo valores
		for(int i=0;i<vals.length;i++) {
			
				//System.out.println(vals.charAt(i));
				if(!sigs.containsKey(vals[i])) {
					sigs.put(vals[i],"");
				}
			
		}
		
		
		
		
		llavess=llavess.replace("[", "").replace("]", "");
		String  tempLlaves[];
		tempLlaves=llavess.split(", ");
		for(int i=0;i<tempLlaves.length;i++) {
			String data[]=tempLlaves[i].split(",");
			String dat=tempLlaves[i];
			//System.out.println("Llave#"+(i+1));
			//System.out.println(data);
			
			for(int j=0;j<data.length;j++) {
					//System.out.println(data[j]);
					String llave=data[j];
					String valor="";
					if(siguientes.containsKey(llave)) {
						valor=siguientes.get(llave).toString();
					}
					else if(!siguientes.containsKey(llave)) {
						valor=siguientes.get(dat).toString();
					}
					
					
					
					String valAntig=sigs.get(llave).toString();
					String valNew=siguientes.get(dat).toString();
					String val=valNew+","+valAntig;
					//System.out.println(val);
					sigs.replace(llave,pop(val));
		}
		}
		
		
		
		
		
		String sigsLlavs[]=sigs.keySet().toString().replace("[", "").replace("]","").replace(" ", "").split(",");
		
		for(int i=0;i<sigsLlavs.length;i++) {
			ArrayList rs = new ArrayList();
			
				
			
			
			String tempVals[]=sigs.get(sigsLlavs[i]).toString().split(",");
			//System.out.println("------LLave"+sigsLlavs[i]+"-------");
			for(int j=0;j<tempVals.length;j++) {
				rs.add(tempVals[j]);
			}
			HashSet hs = new HashSet(); 
			hs.addAll(rs); 
			rs.clear(); 
			rs.addAll(hs);
			//System.out.println(rs);
			sigs.replace(sigsLlavs[i], rs.toString().replace("[", "").replace("]",""));
			
		}
		
	
		grafTabSiguientes();
		
		//Metiendo raiz.primero como s0
		estados.put("S0",pop(Raiz.getprimero()));
		estadosAlrv.put(pop(Raiz.getprimero()),"S0");
		contadorEstados++;
		
		generarEstados();
		generarTrassiciones();
		grafEstados();
		genenerarExpReg(Raiz);
		expReg=expReg.replace("#", "").replace("\"", "").replace(" ","\" \"" ).replace(".", "").replace("°", ".");
		
		String conj[]=conjuntos.keySet().toString().replace("[", "").replace("]", "").replace(" ", "").split(",");
		for(int i=0;i<conj.length;i++) {
			expReg=expReg.replace(conj[i],conjuntos.get(conj[i]).toString());
			
		}
		exps.put(nm, expReg); 
		
		
		
		
		System.out.println("Siguientes: "+siguientes);
		System.out.println("Sigs: "+sigs);
		System.out.println("Hojas: "+hojas);
		System.out.println("Estados: "+estados);
		System.out.println("Expresiones: "+conjuntos);
		System.out.println("Aceptacion: "+aceptacion);
		System.out.println("Nombre: "+nm);
		System.out.println("Expresion regular: "+expReg);
		System.out.println("Expresiones Regulares: "+exps);
		//System.out.println("Estados: "+estados);
	}
	
	public static void grafTabSiguientes() {
			
			String cod="";
			cod+="digraph {\n"
					+ "  node [ shape=none fontname=Helvetica ]\n"
					+ " n1 [ label = <\n"
					+ "<table>\n"
					+ "<tr><td colspan=\"2\" bgcolor=\"cadetblue\">Hojas</td><td colspan=\"1\" bgcolor=\"crimson\">Siguientes</td></tr>\n";
			
			String llaves=sigs.keySet().toString();
			llaves=llaves.replace("[", "").replace("]", "");
			String  tempLlaves[];
			tempLlaves=llaves.split(", ");
			
			//System.out.println("Imprimiendo llaves desde metodo grafico siguientes");
			for(int i=0;i<tempLlaves.length;i++) {
				String id_hoja=tempLlaves[i];
				String hoja=hojas.get(id_hoja).toString();
				//System.out.println(id_hoja+"-"+hoja);
				String s=sigs.get(tempLlaves[i]).toString();//(String) sigs.get(tempLlaves[i].charAt(0));
				cod+="<tr><td bgcolor=\"darkgoldenrod1\">"+id_hoja+"</td><td bgcolor=\"darkseagreen4\">"+hoja+"</td><td bgcolor=\"cyan3\">"+s+"</td></tr>";		 
			}
			
			cod+=" </table>>]\n"
					+ "}";
			
			
			
			
			
			
			FileWriter fichero = null;
	        PrintWriter pw = null;
	        try {
	            fichero = new FileWriter("src/Graficos/Grafico siguientes/" +nm+ ".dot");
	            pw = new PrintWriter(fichero);
	            pw.println(cod);
	        } catch (Exception e) {
	            System.out.println("error, no se realizo el archivo"+e);
	        } finally {
	            try {
	                if (null != fichero) {
	                    fichero.close();
	                }
	            } catch (Exception e2) {
	                e2.printStackTrace();
	            }
	        }
	        //para compilar el archivo dot y obtener la imagen
	        try {
	            //direcciÃ¯Â¿Â½n doonde se ecnuentra el compilador de graphviz
	            String dotPath = "C:/Program Files/Graphviz/bin/dot.exe";
	            //direcciÃ¯Â¿Â½n del archivo dot
	            String fileInputPath = "src/Graficos/Grafico siguientes/" +nm+ ".dot";
	            //direcciÃ¯Â¿Â½n donde se creara la magen
	            String fileOutputPath = "src/Graficos/Grafico siguientes/" + nm +".jpg";
	            //tipo de conversÃ¯Â¿Â½n
	            String tParam = "-Tjpg";
	            String tOParam = "-o";
	
	            String[] cmd = new String[5];
	            cmd[0] = dotPath;
	            cmd[1] = tParam;
	            cmd[2] = fileInputPath;
	            cmd[3] = tOParam;
	            cmd[4] = fileOutputPath;
	
	            Runtime rt = Runtime.getRuntime();
	
	            rt.exec(cmd);
	
	        } catch (Exception ex) {
	            ex.printStackTrace();
	        } finally {
	        }
		
	        System.out.println(" -----------------------------------------");
	        System.out.println("| Tabla de siguientes generada con exito |");
	        System.out.println(" -----------------------------------------");
		}
	
	
	
	public static void generarEstados() {
		
		
		 if(verificar!=contadorEstados) {		
	     		System.out.println("verificando el estado S"+verificar);
	     		String cad="S"+verificar;
	         	
	     		
	     		String tempsEstados[]=estados.get(cad).toString().split(",");
	     		
	     		
	     		for(int i=0;i<tempsEstados.length;i++) {
	     			//System.out.println(tempsEstados[i]);
	     			String rps="";
	     			if(tempsEstados[i]!="") {
		         		rps+=sigs.get(tempsEstados[i]).toString().replace(" ", "");
		         		//System.out.println(tempsEstados[i]+" - : "+rps);
		         		for(int j=i+1;j<tempsEstados.length;j++) {
		         			if(hojas.get(tempsEstados[i]).equals(hojas.get(tempsEstados[j]))) {
		         				rps+=","+sigs.get(tempsEstados[j]).toString().replace(" ", "");
		         				
		         				tempsEstados[j]="";
		         				
		         			}
		         		}
		         		
		     			//System.out.println("rps: "+rps);
		     			
		     			if(!estados.containsValue(rps) && rps!="") {
		     				
		     				
		    											
							for(int c=0;c<rps.length();c++) {
								if(sigs.get(rps.charAt(c))=="") {
									aceptacion.add(("S"+contadorEstados));
								}
							}					
		    				estados.put(("S"+(contadorEstados)),rps);
		    				estadosAlrv.put(rps,("S"+(contadorEstados)));
		    				contadorEstados++;
		    				verificar++;
		    				//System.out.println("Con "+rps+" salgo a S"+verificar);
		    				generarEstados();
					}
	     		}
	     	}
		 }		 
 }   		
	     	
	 public static void generarTrassiciones() {
		 
		 
		 String std[]=estados.keySet().toString().replace("[", "").replace("]", "").replace(" ", "").replace("S", "").split(",");
		 
		 
		 int[] values = Arrays.stream(std)
                 .mapToInt(Integer::parseInt)
                 .toArray();
 		 Arrays.sort(values);
    	 
 		for(int i=0;i<std.length;i++) {
 			std[i]="S"+String.valueOf(values[i]);
 		}
 		
 		
 		
 		
 		
 		
 		for(int i=0;i<std.length;i++) {
 			String valEstado[]=estados.get(std[i]).toString().replace(" ", "").split(",");
 			for(int m=0;m<valEstado.length;m++) {
 				if(hojas.get(valEstado[m])=="#") {
 					System.out.println(std[i]+" aceptado");
 					aceptacion.add(std[i]);
 				}
 				
 			}
 			
 			
 			System.out.println("----------------"+std[i]+"----------------");
 			System.out.println(Arrays.toString(valEstado));
 			for(int m=0;m<valEstado.length;m++) {
 				String rps="";
 				
 				if(valEstado[m]!="" && hojas.get(valEstado[m])!="#") {
 					rps+=sigs.get(valEstado[m]).toString().replace(" ", "");
 					String transi="";
 					transi=hojas.get(valEstado[m]).toString();
 				
	 				for(int s=m+1;s<valEstado.length;s++) {
	 					if(hojas.get(valEstado[m]).equals(hojas.get(valEstado[s]))) {
	         				rps+=","+sigs.get(valEstado[s]).toString();
	         				
	         				valEstado[s]="";
	         				
	         			}
	 				}
	 				
	 				if(transi.equals("\" \"")) {
	 					transi="\\\" \\\"";
	 				}
	 				else {
	 					transi=transi.replace("\"", "");
	 				}
	 				System.out.println("Transi: "+transi);
	 				System.out.println("RPS: "+rps);
	 				System.out.println(std[i]+"->"+transi+"->"+estadosAlrv.get(rps));
	 				codigoAFD+=std[i]+"->"+estadosAlrv.get(rps)+" "+"[label=\""+transi+"\"]\n";
 				}
 				
 				
 			}
 			
 			/*
 			 * for(int j=0;j<valEstado.length;j++) {
 				String siguiente=sigs.get(valEstado[j]).toString().replace(" ", "");
 				System.out.println(std[i]+"="+valEstado[j]+"="+hojas.get(valEstado[j])+"="+siguiente+"->"+estadosAlrv.get(siguiente));
 				
 			}
 			 */
 			
 		}
 		
 		
 		for(int i=0;i<std.length;i++) {
 			if(aceptacion.contains(std[i])) {
 				codigoNodos+=std[i]+" [shape=doublecircle label=\""+std[i]+"\"] \n";
 			}
 			else {
 				codigoNodos+=std[i]+" [shape=circle label=\""+std[i]+"\"] \n";
 			}
 			
 		}
 		
 		System.out.println(codigoNodos);
 		System.out.println(codigoAFD);
 		grafAFD(codigoNodos, codigoAFD);
 		System.out.println(estados);
 		System.out.println(estadosAlrv);
 		
	 }
		
		
		
	public static void grafEstados() {
		
		
	    	
	   
	    	
	    String cod="";
		cod+="digraph {\n"
				+ "  node [ shape=none fontname=Helvetica ]\n"
				+ " n1 [ label = <\n"
				+ "<table>\n"
				+ " <tr><td colspan=\"1\" bgcolor=\"brown1\">Simbolo</td> <td colspan=\"1\" bgcolor=\"cadetblue\">Estado</td><td colspan=\"1\" bgcolor=\"darksalmon\">Aceptacion</td></tr>";
			
	   
		 String tempEstados[]=estados.keySet().toString().replace("[", "").replace("]", "").replace(" ", "").replace("S", "").split(",");
		
		 
		 int[] values = Arrays.stream(tempEstados)
                 .mapToInt(Integer::parseInt)
                 .toArray();
 		 Arrays.sort(values);
    	 
 		for(int i=0;i<tempEstados.length;i++) {
 			tempEstados[i]="S"+String.valueOf(values[i]);
 		}
 		
		 	
		  for(int i=0;i<tempEstados.length;i++) {
			  
			  if(aceptacion.contains(tempEstados[i])) {
		    		cod+=" <tr><td bgcolor=\"darkolivegreen1\">"+estados.get(tempEstados[i])+"</td><td bgcolor=\"coral\">"+(tempEstados[i])+ "</td> <td bgcolor=\"coral\"> True </td></tr>";
		    	}
		    	else {
		    		cod+=" <tr><td bgcolor=\"darkolivegreen1\">"+estados.get(tempEstados[i])+"</td><td bgcolor=\"coral\">"+(tempEstados[i])+ "</td> <td bgcolor=\"coral\"> False </td></tr>";
		    	}
		    	
		   }
		
		 cod+=" </table>>]\n"
				+ "}";
		
		//System.out.println(cod);
		
		
		
		
		FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("src/Graficos/Grafico estados/" +nm+ ".dot");
            pw = new PrintWriter(fichero);
            pw.println(cod);
        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo"+e);
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
        //para compilar el archivo dot y obtener la imagen
        try {
            //direcciÃ¯Â¿Â½n doonde se ecnuentra el compilador de graphviz
            String dotPath = "C:/Program Files/Graphviz/bin/dot.exe";
            //direcciÃ¯Â¿Â½n del archivo dot
            String fileInputPath = "src/Graficos/Grafico estados/" +nm+ ".dot";
            //direcciÃ¯Â¿Â½n donde se creara la magen
            String fileOutputPath = "src/Graficos/Grafico estados/" + nm +".jpg";
            //tipo de conversÃ¯Â¿Â½n
            String tParam = "-Tjpg";
            String tOParam = "-o";

            String[] cmd = new String[5];
            cmd[0] = dotPath;
            cmd[1] = tParam;
            cmd[2] = fileInputPath;
            cmd[3] = tOParam;
            cmd[4] = fileOutputPath;

            Runtime rt = Runtime.getRuntime();

            rt.exec(cmd);

        } catch (Exception ex) {
            ex.printStackTrace();
        } finally {
        }
	
        System.out.println(" -----------------------------------------");
        System.out.println("| Tabla de estados generada con exito |");
        System.out.println(" -----------------------------------------");
	}
	
	
	
	public static void grafAFD(String nodos,String enlaces) {
		
		String cadena="";
    	cadena+="digraph G {\n"
    			+ "  rankdir=LR \n";
    	
    	cadena+=nodos;
    	cadena+=enlaces;
    	cadena+="}";
				
		
		FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("src/Graficos/Grafico AFD/" + nm + ".dot");
            pw = new PrintWriter(fichero);
            pw.println(cadena);
        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo"+e);
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
        //para compilar el archivo dot y obtener la imagen
        try {
            //direcciï¿½n doonde se ecnuentra el compilador de graphviz
            String dotPath = "C:/Program Files/Graphviz/bin/dot.exe";
            //direcciï¿½n del archivo dot
            String fileInputPath = "src/Graficos/Grafico AFD/" + nm + ".dot";
            //direcciï¿½n donde se creara la magen
            String fileOutputPath = "src/Graficos/Grafico AFD/" + nm + ".jpg";
            //tipo de conversï¿½n
            String tParam = "-Tjpg";
            String tOParam = "-o";

            String[] cmd = new String[5];
            cmd[0] = dotPath;
            cmd[1] = tParam;
            cmd[2] = fileInputPath;
            cmd[3] = tOParam;
            cmd[4] = fileOutputPath;

            Runtime rt = Runtime.getRuntime();

            rt.exec(cmd);

        } catch (Exception ex) {
            ex.printStackTrace();
        } finally {
        }

  	 
        System.out.println(" -----------------------------------------");
        System.out.println("|      Grafo AFD generada con exito       |");
        System.out.println(" -----------------------------------------");
        
        System.out.println(cadena);
		
		
	}
	
	

	public static void genenerarExpReg(Nodo r) {
		
		if(r!=null) {
			
			
			if(r.getValor()=="|" && p_a==false) {
				expReg+="(";
				cerrar=r.getprimero();
				p_a=true;
			}
			
			
			
			
			genenerarExpReg(r.getHizq());
			
			if(r.getValor().equals("\".\"")) {
				expReg+="°";
			}
			expReg+=r.getValor();
			
			
			
			
			genenerarExpReg(r.hder);
			
			 if(r.getValor()=="|" && p_a==true && r.getprimero()==cerrar) {
					expReg+=")";
					p_a=false;
					cerrar="";
				}
			
		}
	}
	    
	public static void verificarExpReg(String nom,String lx) {
		
		System.out.println("+++ "+nom+" - "+lx);
		String lex="";
		for(int i=1;i<lx.length()-1;i++) {
			lex+=lx.charAt(i);
		}
		
		if(exps.containsKey(nom)) {
			json+="{\n";
			json+="\"Valor\": \""+lex+"\",\n";
			json+="\"ExpresionRegular\": \""+nom+"\",\n";
			String patron=exps.get(nom).toString().replace("\" \"", "\\s");
			lex=lex.replace("\\", "");
			System.out.println("Patron: "+patron+" Cadena a evaluar: "+lex);
			
			
			Pattern pat = Pattern.compile(patron);
		    Matcher mat = pat.matcher(lex);                                                                           
		    if (mat.matches()) {
		    	json+="\"ExpresionRegular\": \""+"Cadena valida"+"\"\n";
		      
		    } else {
		    	json+="\"ExpresionRegular\": \""+"Cadena no valida"+"\"\n";                                                                             
		    }
		    json+="},\n";
		}
		else {
			System.out.println("No existe un patron para la expresion regular: "+nom);
		}
			
	}

	public static void reporteJson() {
		String cadena="";
		cadena+="[\n";
		cadena+=pop(json);
		cadena+="]\n";
		System.out.println(cadena);
		FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("src/Reportes/" + "Reporte" + ".JSON");
            pw = new PrintWriter(fichero);
            pw.println(cadena);

        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo"+e);
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
        
	}
	


}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {
  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // NOTACIONER ::= ECOM_EXP 
            {
              Nodo RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String val = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				String prim=parser.IDS+",";
				String ult=parser.IDS+",";
				Nodo nuevoDec=new Nodo(null,null,val,parser.contid,parser.IDS,"N",prim,ult);
				parser.IDS++;
				parser.contid++;
				RESULT=nuevoDec;
			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NOTACIONER",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // NOTACIONER ::= ESP_CONJER 
            {
              Nodo RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String val = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			
				String prim=parser.IDS+",";
				String ult=parser.IDS+",";
				Nodo esp=new Nodo(null,null,val,parser.contid,parser.IDS,"N",prim,ult);
				
				parser.IDS++;
				parser.contid++;
				RESULT=esp;
			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NOTACIONER",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // NOTACIONER ::= ID_CONJER 
            {
              Nodo RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String val = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			
				String prim=parser.IDS+",";
				String ult=parser.IDS+",";
				Nodo nuevoidconer=new Nodo(null,null,val.replace("{","").replace("}",""),parser.contid,parser.IDS,"N",prim,ult);
				
				parser.IDS++;
				parser.contid++;
				
				RESULT=nuevoidconer;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NOTACIONER",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // NOTACIONER ::= INTERROGACION NOTACIONER 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Nodo a = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			
				String prim=a.getprimero();
				String ult=a.getUltimo();
				Nodo nuevaInter=new Nodo(a,null,"?",parser.contid,0,"A",prim,ult);
				parser.contid++;
				RESULT=nuevaInter;			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NOTACIONER",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // NOTACIONER ::= ASTERISCO NOTACIONER 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Nodo a = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				String prim=a.getprimero();
				String ult=a.getUltimo();
				
				Nodo nuevoAst=new Nodo(a,null,"*",parser.contid,0,"A",prim,ult);
				parser.contid++;
				RESULT=nuevoAst;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NOTACIONER",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // NOTACIONER ::= MAS NOTACIONER 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Nodo a = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				String prim=a.getprimero();
				String ult=a.getUltimo();
				
				Nodo nuevoMas=new Nodo(a,null,"+",parser.contid,0,"N",prim,ult);
				parser.contid++;
				RESULT=nuevoMas;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NOTACIONER",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // NOTACIONER ::= CONCA NOTACIONER NOTACIONER 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Nodo a = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Nodo b = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				String an;
				String prim;
				String ult;
				if(a.getAnulable()=="A" && b.getAnulable()=="A"){
					an="A";
				}else{
					an="N";
				}
				
				if(a.getAnulable()=="A"){
					prim=a.getprimero()+b.getprimero();
				}else{
					prim=a.getprimero();
				}
				
				if(b.getAnulable()=="A"){
					ult=a.getUltimo()+b.getUltimo();
				}else{
					ult=b.getUltimo();
				}
				Nodo nuevaCon=new Nodo(a,b,".",parser.contid,0,an,prim,ult);
				parser.contid++;
				RESULT=nuevaCon;
			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NOTACIONER",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // NOTACIONER ::= OR NOTACIONER NOTACIONER 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Nodo a = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Nodo b = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				String an;
				if(a.getAnulable()=="A" || b.getAnulable()=="A"){
					an="A";
				}else{
					an="N";
				}
				
				String prim=a.getprimero()+b.getprimero();
				String ult=a.getUltimo()+b.getUltimo();
				
				Nodo nuevaOr=new Nodo(a,b,"|",parser.contid,0,an,prim,ult);
				parser.contid++;
				RESULT=nuevaOr;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NOTACIONER",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // ER ::= NOMBRES GUION FLECHA NOTACIONER NT$5 PUNTO_COMA 
            {
              Nodo RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Nodo) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Nodo valor = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
		parser.inOrden();
		//System.out.println(parser.sigs);
		//System.out.println(parser.hojas);
		
		
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ER",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // NT$5 ::= 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Nodo valor = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

	 String prim=parser.IDS+"";
	 String ult=parser.IDS+"";
	 String prime;
	 String ulti;
	 Nodo nuevofinal=new Nodo(null,null,"#",parser.contid,parser.IDS,"N",prim,ult);
	 parser.contid++;
	 if(valor.getAnulable()=="A"){
	 	prime=valor.getprimero()+ult;
	 }else{
	 	prime=valor.getprimero();
	 }
	 
	 ulti=nuevofinal.getUltimo();
	 Nodo nuevaraiz=new Nodo(valor,nuevofinal,".",parser.contid,0,"N",prime,ult);
	 parser.Raiz=nuevaraiz;
	 //System.out.println("Esta es la Raiz->"+parser.Raiz.getValor());
	 parser.graficarArbol(nuevaraiz,a);
	 parser.nm=a;
	 parser.IDS=1;
	 
	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$5",14, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // POLACA ::= ER 
            {
              String RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("POLACA",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // POLACA ::= POLACA ER 
            {
              String RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("POLACA",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // CJ ::= RESERVADA DOS_PUNTOS NOMBRES GUION FLECHA CONJUNTO NT$4 PUNTO_COMA 
            {
              String RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (String) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int llaveleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int llaveright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		String llave = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String valor = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		System.out.println("esta es la linea del conjunto");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("CJ",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // NT$4 ::= 
            {
              String RESULT =null;
		int llaveleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int llaveright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String llave = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String valor = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

		System.out.println("*************************************"+llave);
	  if(valor.contains("~")) {
			valor="["+valor+"]";
			valor=valor.replace("~", "-");
		}
		else {
			valor=valor.replace(",", "|");
			valor="("+valor+")";
		}
	  	
		parser.conjuntos.put(llave,valor);
	  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$4",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // LEXEME ::= NOMBRES DOS_PUNTOS LEXEMA NT$3 PUNTO_COMA 
            {
              String RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (String) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int nomleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int nomright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		String nom = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int lxleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int lxright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String lx = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("LEXEME",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // NT$3 ::= 
            {
              String RESULT =null;
		int nomleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int nomright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String nom = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int lxleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lxright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String lx = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
parser.verificarExpReg(nom,lx);
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$3",12, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // LEX ::= LEXEME 
            {
              String RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("LEX",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // LEX ::= LEX LEXEME 
            {
              String RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("LEX",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // CONJU ::= CJ 
            {
              String RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("CONJU",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // CONJU ::= CONJU CJ 
            {
              String RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("CONJU",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // SENTENCIAS ::= LLAVE_A NT$0 CONJU POLACA DELIMITADOR DELIMITADOR NT$1 LEX NT$2 LLAVE_C 
            {
              String RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (String) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 parser.exps.clear();
              CUP$parser$result = parser.getSymbolFactory().newSymbol("SENTENCIAS",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // NT$2 ::= 
            {
              String RESULT =(String) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
parser.reporteJson();
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$2",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // NT$1 ::= 
            {
              String RESULT =(String) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
System.out.println("Conjuntos: "+parser.conjuntos);
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$1",10, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // NT$0 ::= 
            {
              String RESULT =null;

			 parser.conjuntos.clear();
			 parser.lexemas.clear();
			 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$0",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // INICIO ::= SENTENCIAS 
            {
              String RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("INICIO",0, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= INICIO EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String start_val = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

